package json-to-go

import (
	"bytes"
	"fmt"
	gofmt "go/format"
	"go/parser"
	"go/token"
	"regexp"
	"strings"

	uuid "github.com/satori/go.uuid"
	"github.com/tidwall/gjson"
)

/*
	JSON-to-Go
	by Matt Holt

	https://github.com/mholt/json-to-go

	A simple utility to translate JSON into a Go type definition.
*/

var (
	floatReg      = regexp.MustCompile(`:(\s*\d*)\.0`)
	numReg        = regexp.MustCompile(`^\d+$`)
	formatReg     = regexp.MustCompile(`[^A-Za-z0-9]`)
	timeReg       = regexp.MustCompile(`\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)`)
	reLiteralUUID = regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
	caseReg1      = regexp.MustCompile(`(^|[^a-zA-Z])([a-z]+)`)
	caseReg2      = regexp.MustCompile(`([A-Z])([a-z]+)`)
)

type field struct {
	value gjson.Result
	count int
}

type Parser struct {
	tabs        int
	innerTabs   int
	parent      string
	output      string
	accumulator string
	stack       []string
	seen        map[string][]string
}

// create a new Parser
func NewParser() *Parser {
	t := &Parser{}
	t.seen = make(map[string][]string)
	t.stack = append(t.stack, "")
	return t
}

// clear Parser inner states, then it can parse another json string
func (t *Parser) Reset() {
	t.tabs, t.innerTabs = 0, 0
	t.parent, t.output, t.accumulator = "", "", ""
	t.seen = make(map[string][]string)
	t.stack = append(t.stack, "")
}

// parse json data in string
func (t *Parser) Parse(jsonData, typename string, flatten bool) string {
	data := floatReg.ReplaceAllString(jsonData, ":$1.1") // hack that forces floats to stay as floats
	scope := gjson.Parse(data)

	if typename == "" {
		typename = "AutoGenerated"
	}

	t.appendx(fmt.Sprintf("\ntype %s ", format(typename)))

	t.parseScope(scope, 0, flatten)

	if flatten {
		t.output += t.accumulator
	}

	formattedOutput, err := fmtOutput(t.output)
	if err != nil {
		//log.Fatal(err)
		return t.output
	}
	return formattedOutput
}

func fmtOutput(s string) (string, error) {
	fs := token.NewFileSet()
	file, err := parser.ParseFile(fs, "", "package x\n"+s, parser.ParseComments)
	if err != nil {
		return "", err
	}

	var output []byte
	buffer := bytes.NewBuffer(output)
	err = gofmt.Node(buffer, fs, file)
	if err != nil {
		return "", err
	}
	return strings.Replace(buffer.String(), "package x\n", "", 1), nil
}

// Given two types, returns the more specific of the two
func mostSpecificPossibleGoType(typ1, typ2 string) string {
	if typ1[:5] == "float" && typ2[:3] == "int" {
		return typ1
	} else if typ1[:3] == "int" && typ2[:5] == "float" {
		return typ2
	} else {
		return "interface{}"
	}
}

func uuidv4() string {
	return uuid.NewV4().String()
}

func getOriginalName(unique string) string {
	//const reLiteralUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
	uuidLength := 36

	if len(unique) >= uuidLength {
		tail := unique[len(unique)-uuidLength:]
		if reLiteralUUID.MatchString(tail) {
			return unique[0 : len(unique)-uuidLength-1]
		}
	}
	return unique
}

func compareObjects(objectA, objectB *gjson.Result) bool {
	return objectA.IsObject() && objectB.IsObject()
}

func compareObjectKeys(itemAKeys, itemBKeys []string) bool {
	lengthA := len(itemAKeys)
	lengthB := len(itemBKeys)

	// nothing to compare, probably identical
	if lengthA == 0 && lengthB == 0 {
		return true
	}

	// duh
	if lengthA != lengthB {
		return false
	}

	mA := make(map[string]struct{}, lengthA)
	mB := make(map[string]struct{}, lengthB)
	for i := 0; i < lengthA; i++ {
		mA[itemAKeys[i]] = struct{}{}
	}
	for i := 0; i < lengthB; i++ {
		mB[itemAKeys[i]] = struct{}{}
	}
	for k := range mA {
		if _, ok := mB[k]; !ok {
			return false
		}
	}

	return true
}

func formatScopeKeys(keys []string) []string {
	dupKeys := append([]string{}, keys...)
	for i := range dupKeys {
		dupKeys[i] = format(dupKeys[i])
	}
	return dupKeys
}

func (t *Parser) appendx(str string) {
	t.output += str
}

func (t *Parser) indent(tabs int) {
	for i := 0; i < tabs; i++ {
		t.output += "\t"
	}
}

func (t *Parser) indenter(tabs int) {
	for i := 0; i < tabs; i++ {
		t.stack[len(t.stack)-1] += "\t"
	}
}

func (t *Parser) appender(str string) {
	t.stack[len(t.stack)-1] += str
}

// Sanitizes and formats a string to make an appropriate identifier in Go
func format(str string) string {
	if str == "" {
		return ""
	}

	if numReg.MatchString(str) {
		str = "Num" + str
	} else if str[0] <= '9' && str[0] >= '0' {
		numbers := map[byte]string{
			'0': "Zero_",
			'1': "One_",
			'2': "Two_",
			'3': "Three_",
			'4': "Four_",
			'5': "Five_",
			'6': "Six_",
			'7': "Seven_",
			'8': "Eight_",
			'9': "Nine_",
		}

		str = numbers[str[0]] + str[1:]
	}

	return formatReg.ReplaceAllString(toProperCase(str), "")
}

// Determines the most appropriate Go type
func goType(val *gjson.Result) string {
	typ := val.Type
	if typ == gjson.Null {
		return "interface{}"
	}

	switch typ {
	case gjson.String:
		if timeReg.MatchString(val.String()) {
			return "time.Time"
		} else {
			return "string"
		}
	case gjson.Number:
		if strings.Contains(val.String(), ".") {
			return "float64"
		}

		intVal := val.Int()
		if intVal > -2147483648 && intVal < 2147483647 {
			return "int"
		} else {
			return "int64"
		}
	case gjson.True, gjson.False:
		return "bool"
	case gjson.JSON:
		if val.IsArray() {
			return "slice"
		}
		return "struct"
	default:
		return "interface{}"
	}
}

// Proper cases a string according to Go conventions
func toProperCase(str string) string {
	// https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.gogogo#L771-L810
	commonInitialisms := map[string]struct{}{
		"ACL":   {},
		"API":   {},
		"ASCII": {},
		"CPU":   {},
		"CSS":   {},
		"DNS":   {},
		"EOF":   {},
		"GUID":  {},
		"HTML":  {},
		"HTTP":  {},
		"HTTPS": {},
		"ID":    {},
		"IP":    {},
		"JSON":  {},
		"LHS":   {},
		"QPS":   {},
		"RAM":   {},
		"RHS":   {},
		"RPC":   {},
		"SLA":   {},
		"SMTP":  {},
		"SQL":   {},
		"SSH":   {},
		"TCP":   {},
		"TLS":   {},
		"TTL":   {},
		"UDP":   {},
		"UI":    {},
		"UID":   {},
		"UUID":  {},
		"URI":   {},
		"URL":   {},
		"UTF8":  {},
		"VM":    {},
		"XML":   {},
		"XMPP":  {},
		"XSRF":  {},
		"XSS":   {},
	}

	str = replaceAllStringSubmatchFunc(caseReg1, str, func(groups []string) string {
		sep := groups[1]
		frag := groups[2]

		upFrag := strings.ToUpper(frag)
		_, ok := commonInitialisms[upFrag]
		if ok {
			return sep + upFrag
		} else {
			return sep + string(upFrag[0]) + strings.ToLower(frag[1:])
		}
	})

	str = replaceAllStringSubmatchFunc(caseReg2, str, func(groups []string) string {
		sep := groups[1]
		frag := groups[2]

		upFrag := strings.ToUpper(frag)

		_, ok := commonInitialisms[sep+upFrag]
		if ok {
			return strings.ToUpper(sep + frag)
		} else {
			return sep + frag
		}
	})

	return str
}

func replaceAllStringSubmatchFunc(re *regexp.Regexp, str string, repl func([]string) string) string {
	result := ""
	lastIndex := 0

	for _, v := range re.FindAllSubmatchIndex([]byte(str), -1) {
		groups := []string{}
		for i := 0; i < len(v); i += 2 {
			groups = append(groups, str[v[i]:v[i+1]])
		}

		//result += repl(groups)
		result += str[lastIndex:v[0]] + repl(groups)
		lastIndex = v[1]
	}

	return result + str[lastIndex:]
}

func (t *Parser) parseScope(scope gjson.Result, depth int, flatten bool) {
	var sliceType string

	if !scope.IsObject() && !scope.IsArray() { // || typeof scope !== "object"
		if flatten && depth >= 2 {
			t.appender(goType(&scope))
		} else {
			t.appendx(goType(&scope))
		}
		return
	}

	if scope.IsArray() {
		arr := scope.Array()
		scopeLength := len(arr)

		for i := 0; i < scopeLength; i++ {
			thisType := goType(&arr[i])
			if sliceType == "" {
				sliceType = thisType
			} else if sliceType != thisType {
				sliceType = mostSpecificPossibleGoType(thisType, sliceType)
				if sliceType == "interface{}" {
					break
				}
			}
		}

		slice := "[]"
		if flatten && (sliceType == "struct" || sliceType == "slice") {
			slice = fmt.Sprintf("[]%s", t.parent)
		}

		if flatten && depth >= 2 {
			t.appender(slice)
		} else {
			t.appendx(slice)
		}
		if sliceType == "struct" {
			allFields := make(map[string]field)

			// for each field counts how many times appears
			for i := 0; i < scopeLength; i++ {
				ss := arr[i] // Object.keys(scope[i])
				keys := getKeys(&ss)
				sm := ss.Map()
				for k := range keys {
					keyname := keys[k]
					ff := sm[keyname]
					if _, ok := allFields[keyname]; !ok {
						allFields[keyname] = field{
							value: ff,
							count: 0,
						}
					} else {
						existingValue := allFields[keyname].value
						currentValue := ff //scope[i][keyname]

						if compareObjects(&existingValue, &currentValue) {
							comparisonResult := compareObjectKeys(
								getKeys(&currentValue),
								getKeys(&existingValue),
							)
							if !comparisonResult {
								uv4 := uuidv4()
								keyname := fmt.Sprintf("%s_%s", keyname, uv4)
								allFields[keyname] = field{
									value: currentValue,
									count: 0,
								}
							}
						}
					}
					v, _ := allFields[keyname]
					allFields[keyname] = field{
						value: v.value,
						count: v.count + 1,
					}
				}
			}

			// create a common struct with all fields found in the current array
			// omitempty dict indicates if a field is optional
			var keys []string
			for k := range allFields {
				keys = append(keys, k)
			}

			scopes := make(map[string]gjson.Result)
			omitempty := make(map[string]bool)
			for k := range keys {
				keyname := keys[k]
				elem := allFields[keyname]

				scopes[keyname] = elem.value
				omitempty[keyname] = elem.count != scopeLength
			}
			t.parseStruct(depth+1, t.innerTabs, scopes, omitempty, flatten) // finally parse the struct !!
		} else if sliceType == "slice" {
			t.parseScope(scope.Array()[0], depth, flatten)
		} else {
			if flatten && depth >= 2 {
				if sliceType == "" {
					t.appender("interface{}")
				} else {
					t.appender(sliceType)
				}
			} else {
				if sliceType == "" {
					t.appendx("interface{}")
				} else {
					t.appendx(sliceType)
				}
			}
		}
	} else {
		if flatten {
			if depth >= 2 {
				t.appender(t.parent)
			} else {
				t.appendx(t.parent)
			}
		}

		t.parseStruct(depth+1, t.innerTabs, scope.Map(), nil, flatten)
	}
}

func getKeys(scope *gjson.Result) []string {
	var keys []string
	mm := scope.Map()
	for k := range mm {
		keys = append(keys, k)
	}
	return keys
}

func (t *Parser) parseStruct(depth, innerTabs int, scope map[string]gjson.Result, omitempty map[string]bool, flatten bool) {
	if flatten {
		if depth >= 2 {
			t.stack = append(t.stack, "\n")
		} else {
			t.stack = append(t.stack, "")
		}
	}

	var someKeys []string
	for k := range scope {
		someKeys = append(someKeys, k)
	}

	if flatten && depth >= 2 {
		parentType := fmt.Sprintf("\ntype %s", t.parent)

		//const scopeKeys = formatScopeKeys(Object.keys(scope))
		scopeKeys := formatScopeKeys(someKeys)

		// this can only handle two duplicate items
		// future improvement will handle the case where there could
		// three or more duplicate keys with different values
		if _, ok := t.seen[t.parent]; ok {
			if compareObjectKeys(scopeKeys, t.seen[t.parent]) {
				t.stack = t.stack[:len(t.stack)-1]
				return
			}
		}
		t.seen[t.parent] = scopeKeys

		t.appender(fmt.Sprintf("%s struct {\n", parentType))
		innerTabs++
		for i := range someKeys {
			keyname := getOriginalName(someKeys[i])
			t.indenter(innerTabs)
			typename := format(keyname)
			t.appender(typename + " ")
			t.parent = typename
			t.parseScope(scope[someKeys[i]], depth, flatten)
			t.appender(" `json:\"" + keyname)
			if omitempty != nil && omitempty[someKeys[i]] {
				t.appender(",omitempty")
			}
			t.appender("\"`\n")
		}
		innerTabs--
		t.indenter(innerTabs)
		t.appender("}")
	} else {
		t.appendx("struct {\n")
		t.tabs++
		for i := range someKeys {
			keyname := getOriginalName(someKeys[i])
			t.indent(t.tabs)
			typename := format(keyname)
			t.appendx(typename + " ")
			t.parent = typename
			t.parseScope(scope[someKeys[i]], depth, flatten)
			t.appendx(" `json:\"" + keyname)
			if omitempty != nil && omitempty[someKeys[i]] {
				t.appendx(",omitempty")
			}
			t.appendx("\"`\n")
		}
		t.tabs--
		t.indent(t.tabs)
		t.appendx("}")
	}
	if flatten {
		t.accumulator += t.stack[len(t.stack)-1]
		t.stack = t.stack[:len(t.stack)-1]
	}
}
